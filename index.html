<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FrameGrid — Video Contact Sheet Generator</title>

  <!-- Tailwind CSS -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React & ReactDOM -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

  <!-- Babel for JSX -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

  <style>
    html { scroll-behavior: smooth; }
    /* Hide number input spinners */
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    input[type=number] { -moz-appearance: textfield; }
  </style>
</head>
<body class="bg-[#FAFAF9]">
  <div id="root"></div>

  <script type="text/babel">
    const { useState, useRef, useEffect } = React;

    // =============================================================================
    // FRAMEGRID — VIDEO CONTACT SHEET GENERATOR
    // =============================================================================

    // ─────────────────────────────────────────────────────────────────────────────
    // ICONS (IBM Carbon Design)
    // ─────────────────────────────────────────────────────────────────────────────

    const UploadIcon = () => (
      <svg width="32" height="32" viewBox="0 0 32 32" fill="currentColor">
        <path d="M16,7l-6.5,6.5,1.4,1.4,4.1-4.1V22h2V10.8l4.1,4.1,1.4-1.4Z"/>
        <path d="M24,22v4H8V22H6v4a2,2,0,0,0,2,2H24a2,2,0,0,0,2-2V22Z"/>
      </svg>
    );

    const VideoIcon = () => (
      <svg width="20" height="20" viewBox="0 0 32 32" fill="currentColor">
        <path d="M21,26H4a2,2,0,0,1-2-2V8A2,2,0,0,1,4,6H21a2,2,0,0,1,2,2v4.06l5.42-3.87A1,1,0,0,1,30,11V21a1,1,0,0,1-1.58.81L23,17.94V24A2,2,0,0,1,21,26ZM4,8V24H21V16a1,1,0,0,1,1.58-.81L28,18.92V13.08l-5.42,3.87A1,1,0,0,1,21,16V8Z"/>
      </svg>
    );

    const GridIcon = () => (
      <svg width="20" height="20" viewBox="0 0 32 32" fill="currentColor">
        <path d="M12,4H6A2,2,0,0,0,4,6v6a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V6A2,2,0,0,0,12,4Zm0,8H6V6h6Z"/>
        <path d="M26,4H20a2,2,0,0,0-2,2v6a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V6A2,2,0,0,0,26,4Zm0,8H20V6h6Z"/>
        <path d="M12,18H6a2,2,0,0,0-2,2v6a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V20A2,2,0,0,0,12,18Zm0,8H6V20h6Z"/>
        <path d="M26,18H20a2,2,0,0,0-2,2v6a2,2,0,0,0,2,2h6a2,2,0,0,0,2-2V20A2,2,0,0,0,26,18Zm0,8H20V20h6Z"/>
      </svg>
    );

    const DownloadIcon = () => (
      <svg width="16" height="16" viewBox="0 0 32 32" fill="currentColor">
        <path d="M26,24v4H6V24H4v4a2,2,0,0,0,2,2H26a2,2,0,0,0,2-2V24Z"/>
        <path d="M16,22l6.5-6.5-1.4-1.4-4.1,4.1V2h-2V18.2l-4.1-4.1L9.5,15.5Z"/>
      </svg>
    );

    const CopyIcon = () => (
      <svg width="16" height="16" viewBox="0 0 32 32" fill="currentColor">
        <path d="M28,10V28H10V10H28m0-2H10a2,2,0,0,0-2,2V28a2,2,0,0,0,2,2H28a2,2,0,0,0,2-2V10a2,2,0,0,0-2-2Z"/>
        <path d="M4,18H2V4A2,2,0,0,1,4,2H18V4H4Z"/>
      </svg>
    );

    const CloseIcon = () => (
      <svg width="16" height="16" viewBox="0 0 32 32" fill="currentColor">
        <path d="M24,9.4,22.6,8,16,14.6,9.4,8,8,9.4,14.6,16,8,22.6,9.4,24,16,17.4,22.6,24,24,22.6,17.4,16Z"/>
      </svg>
    );

    const CheckIcon = () => (
      <svg width="16" height="16" viewBox="0 0 32 32" fill="currentColor">
        <path d="M13,24.5l-8-8,1.4-1.4L13,21.7,25.6,9.1,27,10.5Z"/>
      </svg>
    );

    const WarningIcon = () => (
      <svg width="20" height="20" viewBox="0 0 32 32" fill="currentColor">
        <path d="M16,2A14,14,0,1,0,30,16,14,14,0,0,0,16,2Zm0,26A12,12,0,1,1,28,16,12,12,0,0,1,16,28Z"/>
        <path d="M15 8H17V19H15zM16 22a1.5 1.5 0 101.5 1.5A1.5 1.5 0 0016 22z"/>
      </svg>
    );

    // ─────────────────────────────────────────────────────────────────────────────
    // UTILITY FUNCTIONS
    // ─────────────────────────────────────────────────────────────────────────────

    const formatDuration = (seconds) => {
      const hrs = Math.floor(seconds / 3600);
      const mins = Math.floor((seconds % 3600) / 60);
      const secs = Math.floor(seconds % 60);
      if (hrs > 0) {
        return `${hrs}:${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      }
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    };

    const formatTimestamp = (seconds) => {
      const mins = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      const ms = Math.floor((seconds % 1) * 100);
      return `${mins}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(2, '0')}`;
    };

    const formatFileSize = (bytes) => {
      if (bytes < 1024) return bytes + ' B';
      if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
      if (bytes < 1024 * 1024 * 1024) return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
      return (bytes / (1024 * 1024 * 1024)).toFixed(2) + ' GB';
    };

    const isValidVideoFile = (file) => {
      const validTypes = ['video/mp4', 'video/quicktime', 'video/x-msvideo', 'video/webm', 'video/x-matroska'];
      return validTypes.includes(file.type) ||
             file.name.match(/\.(mp4|mov|avi|webm|mkv)$/i);
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // UPLOAD AREA COMPONENT
    // ─────────────────────────────────────────────────────────────────────────────

    const UploadArea = ({ onFileSelect, disabled }) => {
      const [isDragging, setIsDragging] = useState(false);
      const fileInputRef = useRef(null);

      const handleDragOver = (e) => {
        e.preventDefault();
        if (!disabled) setIsDragging(true);
      };

      const handleDragLeave = (e) => {
        e.preventDefault();
        setIsDragging(false);
      };

      const handleDrop = (e) => {
        e.preventDefault();
        setIsDragging(false);
        if (disabled) return;

        const file = e.dataTransfer.files[0];
        if (file && isValidVideoFile(file)) {
          onFileSelect(file);
        }
      };

      const handleClick = () => {
        if (!disabled) fileInputRef.current?.click();
      };

      const handleFileChange = (e) => {
        const file = e.target.files[0];
        if (file && isValidVideoFile(file)) {
          onFileSelect(file);
        }
      };

      return (
        <div
          onClick={handleClick}
          onDragOver={handleDragOver}
          onDragLeave={handleDragLeave}
          onDrop={handleDrop}
          className={`
            relative rounded-xl border-2 border-dashed p-12 text-center cursor-pointer
            transition-all duration-200
            ${isDragging
              ? 'border-[#11362A] bg-[#F4F6F0]'
              : 'border-[#E8E8E5] bg-white hover:border-[#889A68] hover:bg-[#FAFAF9]'
            }
            ${disabled ? 'opacity-50 cursor-not-allowed' : ''}
          `}
        >
          <input
            ref={fileInputRef}
            type="file"
            accept="video/mp4,video/quicktime,video/x-msvideo,video/webm,.mp4,.mov,.avi,.webm,.mkv"
            onChange={handleFileChange}
            className="hidden"
          />
          <div className="text-[#4A7561] mb-4 flex justify-center">
            <UploadIcon />
          </div>
          <p className="text-base font-medium text-[#0B241C] mb-2">
            Drop your video here
          </p>
          <p className="text-sm text-[#4A7561]">
            or click to browse. Supports MP4, MOV, WebM
          </p>
        </div>
      );
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // VIDEO INFO CARD
    // ─────────────────────────────────────────────────────────────────────────────

    const VideoInfoCard = ({ metadata, onRemove }) => (
      <div className="bg-[#F4F6F0] rounded-xl p-4 border border-[#E8E8E5]">
        <div className="flex items-start gap-3">
          <div className="w-10 h-10 rounded-lg bg-[#11362A] flex items-center justify-center text-white flex-shrink-0">
            <VideoIcon />
          </div>
          <div className="flex-1 min-w-0">
            <p className="text-sm font-medium text-[#0B241C] truncate" title={metadata.name}>
              {metadata.name}
            </p>
            <p className="text-xs text-[#4A7561]">
              {formatDuration(metadata.duration)} · {metadata.width}×{metadata.height} · {formatFileSize(metadata.size)}
            </p>
          </div>
          <button
            onClick={onRemove}
            className="p-1.5 rounded hover:bg-[#E8E8E5] transition-colors text-[#4A7561] hover:text-[#0B241C] flex-shrink-0"
            title="Remove video"
          >
            <CloseIcon />
          </button>
        </div>
      </div>
    );

    // ─────────────────────────────────────────────────────────────────────────────
    // CONTROLS PANEL
    // ─────────────────────────────────────────────────────────────────────────────

    const ControlsPanel = ({ config, onChange, onGenerate, disabled, generating }) => {
      const totalFrames = config.rows * config.cols;

      return (
        <div className="bg-white rounded-xl p-6 border border-[#E8E8E5]">
          <h3 className="text-base font-semibold text-[#0B241C] mb-4">Settings</h3>

          {/* Grid Dimensions */}
          <div className="mb-5">
            <label className="text-xs font-semibold uppercase tracking-wider text-[#737370] mb-2 block">
              Grid Size
            </label>
            <div className="flex items-center gap-3">
              <div className="flex-1">
                <input
                  type="number"
                  min="1"
                  max="10"
                  value={config.rows}
                  onChange={(e) => onChange({ ...config, rows: Math.max(1, Math.min(10, parseInt(e.target.value) || 1)) })}
                  className="w-full px-3 py-2 text-sm border border-[#E8E8E5] rounded-lg focus:outline-none focus:border-[#11362A] text-center"
                />
                <p className="text-xs text-[#737370] text-center mt-1">Rows</p>
              </div>
              <span className="text-[#737370]">×</span>
              <div className="flex-1">
                <input
                  type="number"
                  min="1"
                  max="10"
                  value={config.cols}
                  onChange={(e) => onChange({ ...config, cols: Math.max(1, Math.min(10, parseInt(e.target.value) || 1)) })}
                  className="w-full px-3 py-2 text-sm border border-[#E8E8E5] rounded-lg focus:outline-none focus:border-[#11362A] text-center"
                />
                <p className="text-xs text-[#737370] text-center mt-1">Columns</p>
              </div>
            </div>
            <p className="text-xs text-[#4A7561] mt-2">{totalFrames} frames total</p>
          </div>

          {/* Timestamp Toggle */}
          <div className="mb-5">
            <label className="flex items-center justify-between cursor-pointer">
              <span className="text-sm text-[#0B241C]">Show Timestamps</span>
              <button
                onClick={() => onChange({ ...config, showTimestamps: !config.showTimestamps })}
                className={`
                  relative w-11 h-6 rounded-full transition-colors duration-200
                  ${config.showTimestamps ? 'bg-[#889A68]' : 'bg-[#E8E8E5]'}
                `}
              >
                <span
                  className={`
                    absolute top-1 w-4 h-4 rounded-full bg-white shadow-sm transition-all duration-200
                    ${config.showTimestamps ? 'left-6' : 'left-1'}
                  `}
                />
              </button>
            </label>
          </div>

          {/* Resolution Selector */}
          <div className="mb-6">
            <label className="text-xs font-semibold uppercase tracking-wider text-[#737370] mb-2 block">
              Resolution
            </label>
            <div className="flex gap-2">
              {['low', 'medium', 'high'].map((res) => (
                <button
                  key={res}
                  onClick={() => onChange({ ...config, resolution: res })}
                  className={`
                    flex-1 px-3 py-2 text-sm rounded-lg transition-colors capitalize
                    ${config.resolution === res
                      ? 'bg-[#11362A] text-white'
                      : 'bg-[#F5F5F3] text-[#4A7561] hover:bg-[#E8E8E5]'
                    }
                  `}
                >
                  {res}
                </button>
              ))}
            </div>
          </div>

          {/* Generate Button */}
          <button
            onClick={onGenerate}
            disabled={disabled || generating}
            className={`
              w-full px-4 py-3 rounded-lg text-white text-sm font-medium
              transition-colors flex items-center justify-center gap-2
              ${disabled || generating
                ? 'bg-[#E8E8E5] text-[#737370] cursor-not-allowed'
                : 'bg-[#11362A] hover:bg-[#0B241C]'
              }
            `}
          >
            {generating ? (
              <>
                <svg className="animate-spin h-4 w-4" viewBox="0 0 24 24">
                  <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4" fill="none" />
                  <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z" />
                </svg>
                Processing...
              </>
            ) : (
              <>
                <GridIcon />
                Generate Contact Sheet
              </>
            )}
          </button>
        </div>
      );
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // PROGRESS INDICATOR
    // ─────────────────────────────────────────────────────────────────────────────

    const ProgressIndicator = ({ stage, progress, message }) => {
      const stages = [
        { id: 'extracting', label: 'Extracting', num: 1 },
        { id: 'stitching', label: 'Stitching', num: 2 },
        { id: 'complete', label: 'Complete', num: 3 },
      ];

      const getStageIndex = (s) => stages.findIndex(st => st.id === s);
      const currentIndex = getStageIndex(stage);

      return (
        <div className="bg-[#F4F6F0] rounded-xl p-6 border border-[#E8E8E5]">
          {/* Stage indicators */}
          <div className="flex items-center justify-between mb-4">
            {stages.map((s, i) => (
              <React.Fragment key={s.id}>
                <div className="flex flex-col items-center">
                  <div
                    className={`
                      w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium
                      transition-colors duration-300
                      ${currentIndex > i
                        ? 'bg-[#11362A] text-white'
                        : currentIndex === i
                          ? 'bg-[#889A68] text-white'
                          : 'bg-[#E8E8E5] text-[#737370]'
                      }
                    `}
                  >
                    {currentIndex > i ? <CheckIcon /> : s.num}
                  </div>
                  <span className={`text-xs mt-1 ${currentIndex >= i ? 'text-[#0B241C]' : 'text-[#737370]'}`}>
                    {s.label}
                  </span>
                </div>
                {i < stages.length - 1 && (
                  <div className={`flex-1 h-0.5 mx-2 ${currentIndex > i ? 'bg-[#11362A]' : 'bg-[#E8E8E5]'}`} />
                )}
              </React.Fragment>
            ))}
          </div>

          {/* Progress bar */}
          <div className="h-2 bg-[#E8E8E5] rounded-full overflow-hidden">
            <div
              className="h-full bg-[#889A68] rounded-full transition-all duration-300"
              style={{ width: `${progress}%` }}
            />
          </div>

          {/* Status message */}
          <p className="text-sm text-[#4A7561] mt-3">{message}</p>
        </div>
      );
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // RESULT CARD (Preview + Download)
    // ─────────────────────────────────────────────────────────────────────────────

    const ResultCard = ({ dataUrl, canvas, filename }) => {
      const [copied, setCopied] = React.useState(false);

      const download = (format) => {
        if (!canvas) return;

        let url;
        if (format === 'png') {
          url = canvas.toDataURL('image/png');
        } else {
          const jpgCanvas = document.createElement('canvas');
          jpgCanvas.width = canvas.width;
          jpgCanvas.height = canvas.height;
          const ctx = jpgCanvas.getContext('2d');
          ctx.fillStyle = '#FFFFFF';
          ctx.fillRect(0, 0, jpgCanvas.width, jpgCanvas.height);
          ctx.drawImage(canvas, 0, 0);
          url = jpgCanvas.toDataURL('image/jpeg', 0.92);
        }

        const link = document.createElement('a');
        link.href = url;
        link.download = `${filename}_contact_sheet.${format}`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      };

      const copyToClipboard = async () => {
        if (!canvas) return;
        try {
          const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/png'));
          await navigator.clipboard.write([
            new ClipboardItem({ 'image/png': blob })
          ]);
          setCopied(true);
          setTimeout(() => setCopied(false), 2000);
        } catch (err) {
          console.error('Failed to copy image:', err);
        }
      };

      return (
        <div className="bg-white rounded-xl border border-[#E8E8E5] overflow-hidden">
          {/* Image preview - fits entire image */}
          <div className="bg-[#F5F5F3] p-4">
            <img
              src={dataUrl}
              alt="Contact sheet"
              className="w-full h-auto"
              draggable={false}
            />
          </div>

          {/* Download toolbar */}
          <div className="flex items-center justify-between px-4 py-3 border-t border-[#E8E8E5] bg-[#FAFAF9]">
            <span className="text-sm text-[#737370]">
              {canvas ? `${canvas.width} × ${canvas.height}px` : ''}
            </span>
            <div className="flex items-center gap-2">
              <button
                onClick={copyToClipboard}
                className="px-4 py-2 rounded-lg text-sm font-medium border border-[#E8E8E5] text-[#0B241C] hover:bg-[#F4F6F0] transition-colors flex items-center gap-2"
              >
                {copied ? <CheckIcon /> : <CopyIcon />}
                {copied ? 'Copied' : 'Copy'}
              </button>
              <button
                onClick={() => download('png')}
                className="px-4 py-2 rounded-lg text-sm font-medium bg-[#11362A] text-white hover:bg-[#0B241C] transition-colors flex items-center gap-2"
              >
                <DownloadIcon />
                PNG
              </button>
              <button
                onClick={() => download('jpg')}
                className="px-4 py-2 rounded-lg text-sm font-medium border border-[#E8E8E5] text-[#0B241C] hover:bg-[#F4F6F0] transition-colors flex items-center gap-2"
              >
                <DownloadIcon />
                JPG
              </button>
            </div>
          </div>
        </div>
      );
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // ERROR BANNER
    // ─────────────────────────────────────────────────────────────────────────────

    const ErrorBanner = ({ error, onDismiss, onRetry }) => {
      if (!error) return null;

      return (
        <div className="bg-[#8B4049]/10 border border-[#8B4049] rounded-lg p-4 flex items-start gap-3">
          <div className="text-[#8B4049] flex-shrink-0">
            <WarningIcon />
          </div>
          <div className="flex-1">
            <p className="text-sm font-medium text-[#8B4049]">{error.message}</p>
            {error.recoverable && onRetry && (
              <button
                onClick={onRetry}
                className="text-sm text-[#8B4049] underline mt-1 hover:no-underline"
              >
                Try again
              </button>
            )}
          </div>
          <button
            onClick={onDismiss}
            className="text-[#8B4049] hover:opacity-70 flex-shrink-0"
          >
            <CloseIcon />
          </button>
        </div>
      );
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // MAIN APP COMPONENT
    // ─────────────────────────────────────────────────────────────────────────────

    const FrameGridApp = () => {
      // State
      const [videoFile, setVideoFile] = useState(null);
      const [videoUrl, setVideoUrl] = useState(null);
      const [videoMetadata, setVideoMetadata] = useState(null);
      const [stage, setStage] = useState('idle');
      const [progress, setProgress] = useState(0);
      const [message, setMessage] = useState('');
      const [error, setError] = useState(null);
      const [gridCanvas, setGridCanvas] = useState(null);
      const [gridDataUrl, setGridDataUrl] = useState(null);
      const [config, setConfig] = useState({
        rows: 3,
        cols: 3,
        showTimestamps: true,
        resolution: 'low'
      });

      // Handle file selection
      const handleFileSelect = async (file) => {
        setError(null);
        setVideoFile(file);

        // Create object URL
        const url = URL.createObjectURL(file);
        setVideoUrl(url);

        // Extract metadata using video element
        const video = document.createElement('video');
        video.preload = 'metadata';

        try {
          await new Promise((resolve, reject) => {
            video.onloadedmetadata = () => {
              setVideoMetadata({
                name: file.name,
                duration: video.duration,
                width: video.videoWidth,
                height: video.videoHeight,
                size: file.size
              });
              resolve();
            };
            video.onerror = () => reject(new Error('Failed to load video. Make sure the format is supported.'));
            video.src = url;
          });
        } catch (err) {
          setError({ message: err.message, recoverable: true });
          URL.revokeObjectURL(url);
          setVideoFile(null);
          setVideoUrl(null);
        }
      };

      // Remove video
      const handleRemoveVideo = () => {
        if (videoUrl) URL.revokeObjectURL(videoUrl);
        setVideoFile(null);
        setVideoUrl(null);
        setVideoMetadata(null);
        setGridCanvas(null);
        setGridDataUrl(null);
        setStage('idle');
        setProgress(0);
        setError(null);
      };

      // Extract frames using Canvas API (no FFmpeg needed!)
      const extractFramesCanvas = async (videoUrl, timestamps, onProgress) => {
        const video = document.createElement('video');
        video.src = videoUrl;
        video.muted = true;
        video.preload = 'auto';
        video.crossOrigin = 'anonymous';

        // Wait for video to be ready
        await new Promise((resolve, reject) => {
          video.onloadeddata = resolve;
          video.onerror = () => reject(new Error('Failed to load video for frame extraction'));
        });

        const frames = [];

        for (let i = 0; i < timestamps.length; i++) {
          // Seek to timestamp
          video.currentTime = timestamps[i];

          // Wait for seek to complete
          await new Promise((resolve) => {
            video.onseeked = resolve;
          });

          // Small delay to ensure frame is rendered
          await new Promise(r => setTimeout(r, 50));

          // Create canvas and draw frame
          const canvas = document.createElement('canvas');
          canvas.width = video.videoWidth;
          canvas.height = video.videoHeight;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(video, 0, 0);

          // Convert to blob
          const blob = await new Promise((resolve) => {
            canvas.toBlob(resolve, 'image/png');
          });

          frames.push({
            blob,
            timestamp: timestamps[i],
            index: i
          });

          onProgress((i + 1) / timestamps.length);
        }

        return frames;
      };

      // Stitch frames into grid
      const stitchFrames = async (frames) => {
        setStage('stitching');
        setMessage('Creating contact sheet...');
        setProgress(70);

        const { rows, cols, showTimestamps, resolution } = config;

        // Target canvas widths for each resolution
        const targetWidth = { low: 1200, medium: 2400, high: 3600 }[resolution];

        // Fixed spacing (not scaled)
        const colGap = 20;
        const margin = 40;

        // Load first frame to get original dimensions
        const firstImg = await createImageBitmap(frames[0].blob);
        const originalWidth = firstImg.width;
        const originalHeight = firstImg.height;

        // Calculate frame width to achieve target canvas width
        // targetWidth = cols * frameWidth + (cols - 1) * colGap + margin * 2
        const frameWidth = Math.round((targetWidth - margin * 2 - (cols - 1) * colGap) / cols);
        const scale = frameWidth / originalWidth;
        const frameHeight = Math.round(originalHeight * scale);

        // Padding and spacing
        const timestampHeight = showTimestamps ? 40 : 0;
        const rowGap = 4 + timestampHeight;

        // Canvas dimensions
        const canvasWidth = cols * frameWidth + (cols - 1) * colGap + margin * 2;
        const canvasHeight = rows * frameHeight + (rows - 1) * rowGap + margin * 2;

        // Create canvas
        const canvas = document.createElement('canvas');
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
        const ctx = canvas.getContext('2d');

        // Fill background (white)
        ctx.fillStyle = '#FFFFFF';
        ctx.fillRect(0, 0, canvasWidth, canvasHeight);

        // Draw frames
        for (let i = 0; i < frames.length && i < rows * cols; i++) {
          const row = Math.floor(i / cols);
          const col = i % cols;
          const x = margin + col * (frameWidth + colGap);
          const y = margin + row * (frameHeight + rowGap);

          const img = await createImageBitmap(frames[i].blob);
          ctx.drawImage(img, x, y, frameWidth, frameHeight);

          // Draw timestamp below frame
          if (showTimestamps) {
            const timeStr = formatTimestamp(frames[i].timestamp);
            const fontSize = Math.round(18 * scale);

            ctx.fillStyle = '#4A4A4A';
            ctx.font = `${fontSize}px system-ui, -apple-system, sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            ctx.fillText(timeStr, x + frameWidth / 2, y + frameHeight + 12);
          }

          setProgress(70 + Math.round(((i + 1) / frames.length) * 25));
          setMessage(`Stitching frame ${i + 1} of ${frames.length}...`);
        }

        setProgress(95);
        return canvas;
      };

      // Generate contact sheet
      const handleGenerate = async () => {
        setError(null);
        setGridCanvas(null);
        setGridDataUrl(null);

        try {
          setStage('extracting');
          setProgress(0);
          setMessage('Preparing to extract frames...');

          const { duration } = videoMetadata;
          const numFrames = config.rows * config.cols;
          const interval = duration / (numFrames + 1);
          const timestamps = Array.from({ length: numFrames }, (_, i) => (i + 1) * interval);

          // Extract frames using Canvas API
          const frames = await extractFramesCanvas(videoUrl, timestamps, (p) => {
            setProgress(Math.round(p * 70));
            setMessage(`Extracting frame ${Math.round(p * numFrames)} of ${numFrames}...`);
          });

          // Stitch into grid
          const canvas = await stitchFrames(frames);

          // Generate preview
          const dataUrl = canvas.toDataURL('image/png');

          setGridCanvas(canvas);
          setGridDataUrl(dataUrl);
          setStage('complete');
          setProgress(100);
          setMessage('Contact sheet generated successfully!');

        } catch (err) {
          console.error('Generation error:', err);
          setError({
            message: err.message || 'Failed to generate contact sheet',
            recoverable: true
          });
          setStage('idle');
          setProgress(0);
        }
      };

      // Cleanup on unmount
      useEffect(() => {
        return () => {
          if (videoUrl) URL.revokeObjectURL(videoUrl);
        };
      }, [videoUrl]);

      const isGenerating = ['extracting', 'stitching'].includes(stage);
      const canGenerate = videoMetadata && !isGenerating;
      const showProgress = isGenerating || stage === 'complete';

      return (
        <div className="min-h-screen flex flex-col">
          {/* Header */}
          <header className="border-b border-[#E8E8E5] bg-white flex-shrink-0">
            <div className="max-w-[1440px] mx-auto px-6 py-4">
              <div className="flex items-center gap-3">
                <div className="w-8 h-8 rounded-lg bg-[#11362A] flex items-center justify-center text-white">
                  <GridIcon />
                </div>
                <div>
                  <h1 className="text-lg font-semibold text-[#0B241C]">FrameGrid</h1>
                  <p className="text-xs text-[#4A7561]">Video Contact Sheet Generator</p>
                </div>
              </div>
            </div>
          </header>

          {/* Main Content - Two Column */}
          <main className="flex-1 flex">
            <div className="max-w-[1440px] w-full mx-auto flex flex-col lg:flex-row">
              {/* Left Sidebar: Controls */}
              <div className="lg:w-[320px] xl:w-[360px] flex-shrink-0 p-6 border-b lg:border-b-0 lg:border-r border-[#E8E8E5] bg-white space-y-4">
                {!videoMetadata ? (
                  <UploadArea onFileSelect={handleFileSelect} disabled={isGenerating} />
                ) : (
                  <>
                    <VideoInfoCard metadata={videoMetadata} onRemove={handleRemoveVideo} />
                    <ControlsPanel
                      config={config}
                      onChange={setConfig}
                      onGenerate={handleGenerate}
                      disabled={!canGenerate}
                      generating={isGenerating}
                    />
                  </>
                )}

                {/* Footer in sidebar on desktop */}
                <div className="hidden lg:block pt-4 mt-auto">
                  <p className="text-xs text-[#737370]">
                    All processing happens locally in your browser. Your videos never leave your device.
                  </p>
                </div>
              </div>

              {/* Right: Preview Area (80%) */}
              <div className="flex-1 p-6 bg-[#F5F5F3] space-y-4">
                {/* Error Banner */}
                {error && (
                  <ErrorBanner
                    error={error}
                    onDismiss={() => setError(null)}
                    onRetry={canGenerate ? handleGenerate : null}
                  />
                )}

                {/* Progress */}
                {showProgress && (
                  <ProgressIndicator stage={stage} progress={progress} message={message} />
                )}

                {/* Result */}
                {gridDataUrl ? (
                  <ResultCard
                    dataUrl={gridDataUrl}
                    canvas={gridCanvas}
                    filename={videoMetadata?.name.replace(/\.[^/.]+$/, '') || 'video'}
                  />
                ) : (
                  !showProgress && (
                    <div className="h-full min-h-[400px] flex items-center justify-center rounded-xl border-2 border-dashed border-[#E8E8E5] bg-white/50">
                      <div className="text-center">
                        <div className="text-[#E8E8E5] mb-3 flex justify-center">
                          <GridIcon />
                        </div>
                        <p className="text-sm text-[#737370]">
                          Upload a video to generate a contact sheet
                        </p>
                      </div>
                    </div>
                  )
                )}
              </div>
            </div>
          </main>

          {/* Footer on mobile */}
          <footer className="lg:hidden border-t border-[#E8E8E5] bg-white">
            <div className="px-6 py-4">
              <p className="text-xs text-[#737370] text-center">
                All processing happens locally in your browser. Your videos never leave your device.
              </p>
            </div>
          </footer>
        </div>
      );
    };

    // ─────────────────────────────────────────────────────────────────────────────
    // RENDER
    // ─────────────────────────────────────────────────────────────────────────────

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<FrameGridApp />);
  </script>
</body>
</html>
